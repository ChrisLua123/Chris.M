
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer


local BASE_COLOR = Color3.fromRGB(0,255,0)

local Toggles = {
	ESP = true,
	Box = true,
	Tracers = true,
	Names = true,
	Skeleton = true,
	Rainbow = false
}

local ESP = {}



local gui = Instance.new("ScreenGui")
gui.Name = "ChrisESP"
gui.ResetOnSpawn = false
gui.Parent = gethui and gethui() or game.CoreGui

local frame = Instance.new("Frame", gui)
frame.Size = UDim2.new(0,220,0,255)
frame.Position = UDim2.new(0,40,0,200)
frame.BackgroundColor3 = Color3.fromRGB(15,15,15)
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true
Instance.new("UICorner", frame).CornerRadius = UDim.new(0,10)

local frameStroke = Instance.new("UIStroke", frame)
frameStroke.Thickness = 2
frameStroke.Color = BASE_COLOR

local function label(text,y,size,color)
	local l = Instance.new("TextLabel",frame)
	l.Size = UDim2.new(1,0,0,size)
	l.Position = UDim2.new(0,0,0,y)
	l.BackgroundTransparency = 1
	l.Text = text
	l.Font = Enum.Font.Code
	l.TextSize = size
	l.TextColor3 = color or BASE_COLOR
	return l
end

label("ESP PANEL",6,18)
label("by chris",26,14,Color3.fromRGB(160,255,160))
label("press F8 to hide",236,12,Color3.fromRGB(140,255,140))

local RainbowButtonStroke

local function makeToggle(text,y,key,isRainbow)
	local b = Instance.new("TextButton",frame)
	b.Size = UDim2.new(0.85,0,0,26)
	b.Position = UDim2.new(0.075,0,0,y)
	b.BackgroundColor3 = Color3.fromRGB(25,25,25)
	b.Font = Enum.Font.Code
	b.TextSize = 15
	b.TextColor3 = BASE_COLOR
	b.AutoButtonColor = false
	Instance.new("UICorner",b).CornerRadius = UDim.new(0,8)

	local stroke = Instance.new("UIStroke", b)
	stroke.Thickness = 1
	stroke.Color = BASE_COLOR
	if isRainbow then RainbowButtonStroke = stroke end

	local function refresh()
		b.Text = text..": "..(Toggles[key] and "ON" or "OFF")
	end

	b.MouseButton1Click:Connect(function()
		Toggles[key] = not Toggles[key]
		refresh()
	end)

	refresh()
end

makeToggle("ESP",55,"ESP")
makeToggle("Box",85,"Box")
makeToggle("Tracers",115,"Tracers")
makeToggle("Names",145,"Names")
makeToggle("Skeleton",175,"Skeleton")
makeToggle("Rainbow ESP",205,"Rainbow",true)

UserInputService.InputBegan:Connect(function(i,gp)
	if gp then return end
	if i.KeyCode == Enum.KeyCode.F8 then
		gui.Enabled = not gui.Enabled
	end
end)



local bonesR15 = {
	{"Head","UpperTorso"},
	{"UpperTorso","LowerTorso"},

	{"UpperTorso","LeftUpperArm"},
	{"LeftUpperArm","LeftLowerArm"},

	{"UpperTorso","RightUpperArm"},
	{"RightUpperArm","RightLowerArm"},

	{"LowerTorso","LeftUpperLeg"},
	{"LowerTorso","RightUpperLeg"}
}

local bonesR6 = {
	{"Head","Torso"},
	{"Torso","Left Arm"},
	{"Torso","Right Arm"},
	{"Torso","Left Leg"},
	{"Torso","Right Leg"}
}

local function newLine()
	local l = Drawing.new("Line")
	l.Thickness = 2.5
	l.Visible = false
	return l
end

local function createESP(p)
	if p == LocalPlayer then return end
	ESP[p] = {
		box = Drawing.new("Square"),
		tracer = newLine(),
		name = Drawing.new("Text"),
		skeleton = {}
	}
end

local function removeESP(p)
	local e = ESP[p]
	if not e then return end
	e.box:Remove()
	e.tracer:Remove()
	e.name:Remove()
	for _,l in pairs(e.skeleton) do l:Remove() end
	ESP[p] = nil
end

for _,p in ipairs(Players:GetPlayers()) do createESP(p) end
Players.PlayerAdded:Connect(createESP)
Players.PlayerRemoving:Connect(removeESP)



RunService.RenderStepped:Connect(function()
	local hue = (tick()*0.25)%1
	local espColor = Toggles.Rainbow and Color3.fromHSV(hue,1,1) or BASE_COLOR
	frameStroke.Color = espColor
	if RainbowButtonStroke then
		RainbowButtonStroke.Color = espColor
	end

	for p,e in pairs(ESP) do
		local c = p.Character
		local hum = c and c:FindFirstChildOfClass("Humanoid")
		local hrp = c and c:FindFirstChild("HumanoidRootPart")

		if not (Toggles.ESP and c and hum and hrp and hum.Health > 0) then
			for _,v in pairs(e) do
				if typeof(v) == "table" then for _,l in pairs(v) do l.Visible=false end
				else v.Visible=false end
			end
			continue
		end

		local _,onScreen = Camera:WorldToViewportPoint(hrp.Position)
		if not onScreen then
			for _,v in pairs(e) do
				if typeof(v) == "table" then for _,l in pairs(v) do l.Visible=false end
				else v.Visible=false end
			end
			continue
		end

		local bones = hum.RigType == Enum.HumanoidRigType.R15 and bonesR15 or bonesR6
		if #e.skeleton ~= #bones then
			for _,l in pairs(e.skeleton) do l:Remove() end
			e.skeleton = {}
			for i=1,#bones do e.skeleton[i] = newLine() end
		end

		local minX,minY = math.huge,math.huge
		local maxX,maxY = -math.huge,-math.huge
		local valid = false

		for i,b in ipairs(bones) do
			local p0,p1 = c:FindFirstChild(b[1]),c:FindFirstChild(b[2])
			local l = e.skeleton[i]
			l.Color = espColor

			if Toggles.Skeleton and p0 and p1 then
				local v0,s0 = Camera:WorldToViewportPoint(p0.Position)
				local v1,s1 = Camera:WorldToViewportPoint(p1.Position)
				if s0 and s1 then
					l.Visible = true
					l.From = Vector2.new(v0.X,v0.Y)
					l.To = Vector2.new(v1.X,v1.Y)
					valid = true
					minX = math.min(minX,v0.X,v1.X)
					minY = math.min(minY,v0.Y,v1.Y)
					maxX = math.max(maxX,v0.X,v1.X)
					maxY = math.max(maxY,v0.Y,v1.Y)
				else
					l.Visible = false
				end
			else
				l.Visible = false
			end
		end

		if not valid then continue end

		local dist = (Camera.CFrame.Position - hrp.Position).Magnitude
		local maxSize = math.clamp(4000 / dist, 40, 120)
		local w = math.clamp(maxX-minX, 25, maxSize) + 6
		local h = math.clamp(maxY-minY, 45, maxSize*1.8) + 8

		e.box.Color = espColor
		e.box.Thickness = 2.5
		e.box.Filled = false
		e.box.Visible = Toggles.Box
		e.box.Position = Vector2.new(minX-3,minY-4)
		e.box.Size = Vector2.new(w,h)

		e.name.Text = p.Name
		e.name.Color = espColor
		e.name.Size = 15
		e.name.Center = true
		e.name.Outline = true
		e.name.Visible = Toggles.Names
		e.name.Position = Vector2.new(minX+w/2,minY-14)

		e.tracer.Color = espColor
		e.tracer.Visible = Toggles.Tracers
		e.tracer.From = Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y)
		e.tracer.To = Vector2.new(minX+w/2,maxY)
	end
end)
